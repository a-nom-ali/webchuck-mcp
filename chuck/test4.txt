// 2048 Retro Arcade Theme with Power-Ups
// A chill earworm with retro arcade vibes and power-up sound effects

// Main synthesizers for melodic elements
SinOsc melody => ADSR melodyEnv => NRev reverb => dac;
TriOsc bass => ADSR bassEnv => dac;

// Power-up sound effects
SinOsc powerUp => ADSR powerEnv => dac;
SqrOsc merge => ADSR mergeEnv => dac;

// Percussion instruments
SinOsc kick => ADSR kickEnv => dac;
Noise snare => BPF snareFilter => ADSR snareEnv => dac;
Noise hihat => BPF hihatFilter => ADSR hihatEnv => dac;

// Global settings
0.2 => reverb.mix;
0.5 => float masterVolume;
110 => float tempo; // BPM
60.0/tempo => float beat;

// Set volumes
0.25 * masterVolume => melody.gain;
0.3 * masterVolume => bass.gain;
0.2 * masterVolume => powerUp.gain;
0.2 * masterVolume => merge.gain;
0.3 * masterVolume => kick.gain;
0.15 * masterVolume => snare.gain;
0.1 * masterVolume => hihat.gain;

// Configure ADSR envelopes
melodyEnv.set(0.01, 0.1, 0.7, 0.3);
bassEnv.set(0.02, 0.1, 0.7, 0.5);
powerEnv.set(0.01, 0.05, 0.0, 0.1);
mergeEnv.set(0.01, 0.1, 0.0, 0.2);
kickEnv.set(0.01, 0.1, 0.0, 0.2);
snareEnv.set(0.01, 0.05, 0.0, 0.1);
hihatEnv.set(0.01, 0.02, 0.0, 0.05);

// Play a note with specific duration
fun void playNote(int scaleIndex, float duration) {
    Std.mtof(scale[scaleIndex]) => melody.freq;
    1 => melodyEnv.keyOn;
    beat * duration * 1::second + now => now;
    1 => melodyEnv.keyOff;
}

// Play a bass note
fun void playBass(int scaleIndex, float duration) {
    Std.mtof(scale[scaleIndex] - 24) => bass.freq;
    1 => bassEnv.keyOn;
    beat * duration * 1::second + now => now;
    1 => bassEnv.keyOff;
}

// Play a complete melody pattern
fun void playMelodyPattern(int pattern[]) {
    for (0 => int i; i < pattern.size(); i++) {
        spork ~ playNote(pattern[i], 0.45);

        // Add occasional power-up sound for variety
        if (i == 3 && Math.random2(0, 10) > 8) {
            spork ~ playPowerUp();
        }

        // Add occasional merge sound for variety
        if (i == 6 && Math.random2(0, 10) > 8) {
            spork ~ playMerge();
        }

        beat * 0.5::second + now => now;
    }
}

// Play a complete bass pattern
fun void playBassPattern(int pattern[]) {
    for (0 => int i; i < pattern.size(); i++) {
        spork ~ playBass(pattern[i], 0.9);
        beat * 1::second + now => now;
    }
}

// Play power-up sound - rising glissando
fun void playPowerUp() {
    for (int i; i < 15; i++) {
        400 + (i * 60) => powerUp.freq;
        1 => powerEnv.keyOn;
        beat * 0.03::second + now => now;
        1 => powerEnv.keyOff;
    }
}

// Play merge sound - chord arpeggio
fun void playMerge() {
    for (int i; i < 3; i++) {
        Std.mtof(scale[7] - (i*4)) => merge.freq;
        1 => mergeEnv.keyOn;
        beat * 0.15::second + now => now;
        1 => mergeEnv.keyOff;
    }
}

// Percussion functions
fun void playKick() {
    50 => Std.mtof => kick.freq;
    1 => kickEnv.keyOn;
    beat * 0.1::second + now => now;
    1 => kickEnv.keyOff;
}

fun void playSnare() {
    1 => snareEnv.keyOn;
    beat * 0.1::second + now => now;
    1 => snareEnv.keyOff;
}

fun void playHihat() {
    1 => hihatEnv.keyOn;
    beat * 0.05::second + now => now;
    1 => hihatEnv.keyOff;
}

// Play drum pattern
fun void playDrumPattern() {
    for (0 => int i; i < 8; i++) {
        // Kick on beats 0, 2, 4, 6
        if (i % 2 == 0) {
            spork ~ playKick();
        }

        // Snare on beats 1, 3, 5, 7
        if (i % 2 == 1) {
            spork ~ playSnare();
        }

        // Hihat on every eighth note
        spork ~ playHihat();

        beat * 0.5::second + now => now;
    }
}

// Configure filters
2000 => snareFilter.freq;
1.0 => snareFilter.Q;
6000 => hihatFilter.freq;
1.0 => hihatFilter.Q;

// C minor pentatonic scale for that retro game feel
[48, 51, 53, 55, 58, 60, 63, 65, 67, 70, 72, 75, 77, 79] @=> int scale[];

// Bass patterns (scale degrees)
[0, 0, 4, 4, 0, 0, 7, 7] @=> int bassPattern1[];
[0, 0, 2, 2, 4, 4, 2, 2] @=> int bassPattern2[];

// Main melody patterns
[0, 2, 4, 7, 4, 2, 4, 0] @=> int melodyPattern1[];
[7, 9, 7, 4, 5, 4, 2, 0] @=> int melodyPattern2[];
[0, 2, 0, 2, 4, 7, 4, 2] @=> int melodyPattern3[];
[4, 7, 9, 7, 4, 2, 0, 2] @=> int melodyPattern4[];

// Main loop
while (true) {
    // Section 1
    spork ~ playDrumPattern();
    spork ~ playBassPattern(bassPattern1);
    playMelodyPattern(melodyPattern1);

    // Section 2
    spork ~ playDrumPattern();
    spork ~ playBassPattern(bassPattern1);
    playMelodyPattern(melodyPattern2);

    // Section 3
    spork ~ playDrumPattern();
    spork ~ playBassPattern(bassPattern2);
    playMelodyPattern(melodyPattern3);

    // Section 4
    spork ~ playDrumPattern();
    spork ~ playBassPattern(bassPattern2);
    playMelodyPattern(melodyPattern4);

    // Power-up feature section
    spork ~ playPowerUp();
    spork ~ playDrumPattern();
    spork ~ playBassPattern(bassPattern1);

    // Create a variation an octave higher
    for (0 => int i; i < melodyPattern1.size(); i++) {
        spork ~ playNote(melodyPattern1[i] + 7, 0.45);
        beat * 0.5::second + now => now;
    }

    // Merge feature section
    spork ~ playMerge();
    spork ~ playDrumPattern();
    spork ~ playBassPattern(bassPattern2);
    playMelodyPattern(melodyPattern2);
}

