// AI-generated generative music using Markov chains
// Define a Markov chain for pitch transitions
[[0.2, 0.5, 0.3], [0.1, 0.2, 0.7], [0.6, 0.3, 0.1]] @=> float transitionMatrix[][];
[60, 64, 67] @=> int pitches[]; // C, E, G

// Sound chain with effects
TriOsc osc => ADSR env => Echo echo => NRev rev => dac;
0.7 => osc.gain;
0.2 => rev.mix;
250::ms => echo.delay;
0.3 => echo.mix;
0.7 => echo.gain;

// ADSR parameters
env.set(10::ms, 100::ms, 0.5, 150::ms);

// Current state (starting with C)
0 => int currentState;

// Generate sequence
for (0 => int i; i < 32; i++) {
    // Get transition probabilities for current state
    transitionMatrix[currentState] @=> float transitions[];

    // Generate random number
    Math.random() => float r;

    // Determine next state based on probability
    0.0 => float cumProb;
    for (0 => int j; j < transitions.size(); j++) {
        cumProb + transitions[j] => cumProb;
        if (r < cumProb) {
            j => currentState;
            break;
        }
    }

    // Play the note for current state
    Std.mtof(pitches[currentState]) => osc.freq;
    1 => env.keyOn;

    // Random duration between 100-300ms
    (100 + Math.random() * 200)::ms => now;

    1 => env.keyOff;
    50::ms => now;
}

// Let the reverb tail fade
500::ms => now;