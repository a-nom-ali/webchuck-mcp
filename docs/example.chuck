// WebChucK Audio Mixing Example
// This demonstrates loading multiple audio files and mixing them with effects

// Master output chain with effects
Gain master => JCRev reverb => Echo echo => NRev nreverb => dac;
0.05 => reverb.mix;
0.2 => echo.mix;
250::ms => echo.delay;
0.6 => echo.gain;
0.1 => nreverb.mix;

// Create a function to load audio files with panning
fun void loadAndPlay(string filename, float gain, float pan, dur delay) {
    SndBuf buffer => Pan2 panner => master;
    filename => buffer.read;
    gain => buffer.gain;
    pan => panner.pan;

    // Start with empty buffer
    buffer.samples() => buffer.pos;

    // Wait for the specified delay
    delay => now;

    // Reset position and play
    0 => buffer.pos;
    buffer.length() => now;
}

// Create rhythmic patterns function
fun void rhythm(string sample, float gain, dur beat, int pattern[], int totalBeats) {
    SndBuf buff => master;
    sample => buff.read;
    gain => buff.gain;

    // Start with empty buffer
    buff.samples() => buff.pos;

    for (0 => int i; i < totalBeats; i++) {
        // Check if this beat should play
        0 => int play;
        for (0 => int j; j < pattern.size(); j++) {
            if (pattern[j] == i % totalBeats) {
                1 => play;
                break;
            }
        }

        if (play) {
            0 => buff.pos;
        }

        beat => now;
    }
}

// Spork multiple tracks in parallel
spork ~ loadAndPlay("bass.wav", 0.7, -0.3, 0::ms);
spork ~ loadAndPlay("piano.wav", 0.5, 0.3, 1000::ms);
spork ~ loadAndPlay("synth.wav", 0.3, 0.0, 2000::ms);

// Create drum patterns
[0, 4, 8, 12] @=> int kickPattern[];
[2, 6, 10, 14] @=> int snarePattern[];
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] @=> int hihatPattern[];

spork ~ rhythm("kick.wav", 0.8, 250::ms, kickPattern, 16);
spork ~ rhythm("snare.wav", 0.6, 250::ms, snarePattern, 16);
spork ~ rhythm("hihat.wav", 0.4, 250::ms, hihatPattern, 16);

// Wait for everything to finish (adjust time as needed)
15::second => now;

// Fade out
for (0.9 => float g; g >= 0.0; g - 0.1 => g) {
    g => master.gain;
    100::ms => now;
}